def _angles_xy(p1: jnp.ndarray, p2: jnp.ndarray) -> Tuple[jnp.ndarray, jnp.ndarray]:
    """
    p1, p2: (...,3)
    returns (theta_x, theta_y): (...,)
    """
    dz = p2[..., 2] - p1[..., 2]
    eps = jnp.asarray(1e-12, dtype=dz.dtype)
    dz = jnp.where(dz == 0, eps, dz)
    theta_y = jnp.arctan2(p2[..., 1] - p1[..., 1], dz)
    theta_x = jnp.arctan2(p2[..., 0] - p1[..., 0], dz)
    return theta_x, theta_y


def scattering_angle_signal(p1, p2, p3, p4) -> jnp.ndarray:
    """
    Exactly matches MATLAB ScatteringAngleSignal().
    Returns s: (N,)
    """
    entry_x, entry_y = _angles_xy(p1, p2)
    exit_x, exit_y = _angles_xy(p3, p4)

    dx = jnp.abs(exit_x - entry_x)
    dy = jnp.abs(exit_y - entry_y)
    s = jnp.sqrt((dx * dx + dy * dy) / 2.0)
    return s


def _variance_terms(xeta: jnp.ndarray, X0: float, p_muon: float, DE: float, const1: float):
    """
    Vectorized variance terms used in GMTE.
    xeta: (...,)
    Returns (var_theta, var_y, var_th_y): each (...,)
    """
    # Guard the log and denominator
    ratio = jnp.maximum(xeta / X0, 1e-12)
    denom = jnp.maximum(p_muon ** 2 - DE * p_muon * xeta, 1e-12)

    variance_theta = const1 * (xeta / X0) * (1.0 / denom) * (1.0 + 0.038 * jnp.log(ratio)) ** 2
    variance_y = (xeta ** 2) * variance_theta / 3.0
    variance_th_y = 0.5 * jnp.sqrt(3.0) * jnp.sqrt(variance_theta * variance_y)
    return variance_theta, variance_y, variance_th_y


def muTRec_Reshma(p1: jnp.ndarray,
                          p2: jnp.ndarray,
                          p3: jnp.ndarray,
                          p4: jnp.ndarray,
                          params: ReconParams) -> Tuple[jnp.ndarray, ...]:
    """
    Vectorized GMTE for a single muon over all z-steps.
    Returns x_gmte, y_gmte, z_gmte, theta_x_gmte, theta_y_gmte  each (T,)
    """
    start_z = params.start_point[2]
    T = int(round(params.cube_size / params.voxel_size))
    z0 = start_z - 1e-3
    z = z0 + params.voxel_size * jnp.arange(T, dtype=jnp.float32)  

    # Entry/exit angles
    entry_x, entry_y = _angles_xy(p1, p2)  # scalars
    exit_x, exit_y = _angles_xy(p3, p4)

    # Assemble small vectors (broadcast later)
    YA_y = jnp.stack([p2[1], entry_y], axis=0)  
    YB_y = jnp.stack([p3[1], exit_y], axis=0)  
    YA_x = jnp.stack([p2[0], entry_x], axis=0)
    YB_x = jnp.stack([p3[0], exit_x], axis=0)

    # Transport matrices as functions of z
    RA = jnp.stack([
        jnp.stack([jnp.ones_like(z), z - p2[2]], axis=-1),
        jnp.stack([jnp.zeros_like(z), jnp.ones_like(z)], axis=-1)
    ], axis=-2)  

    RB = jnp.stack([
        jnp.stack([jnp.ones_like(z), p3[2] - z], axis=-1),
        jnp.stack([jnp.zeros_like(z), jnp.ones_like(z)], axis=-1)
    ], axis=-2)  

    # Covariance blocks
    xeta1 = z - p1[2] 
    vt1, vy1, vth1 = _variance_terms(xeta1, params.X0, params.p_muon, params.DE, params.const1)
    S1 = jnp.stack([
        jnp.stack([vy1, vth1], axis=-1),
        jnp.stack([vth1, vt1], axis=-1)
    ], axis=-2)  

    xeta2 = p4[2] - z 
    vt2, vy2, vth2 = _variance_terms(xeta2, params.X0, params.p_muon, params.DE, params.const1)
    S2 = jnp.stack([
        jnp.stack([vy2, vth2], axis=-1),
        jnp.stack([vth2, vt2], axis=-1)
    ], axis=-2)  

    # Helper to compute MLP solution for (YA, YB)
    def solve_component(YA: jnp.ndarray, YB: jnp.ndarray):
        # Broadcast Y vectors to (T,2)
        YA_b = jnp.broadcast_to(YA, (z.shape[0], 2))
        YB_b = jnp.broadcast_to(YB, (z.shape[0], 2))

        invS1 = jnp.linalg.inv(S1)  # (T,2,2)
        S2_RB = jnp.linalg.solve(S2, RB)  # (T,2,2)
        RB_T = jnp.swapaxes(RB, -1, -2)  # (T,2,2)
        M = invS1 + RB_T @ S2_RB  # (T,2,2)

        rhs1 = invS1 @ (RA @ YA_b[..., None])  # (T,2,1)
        rhs2 = RB_T @ (jnp.linalg.solve(S2, YB_b[..., None]))  
        rhs = (rhs1 + rhs2)[..., 0]  # (T,2)

        # out   = jnp.linalg.solve(M, rhs)                
        out = jnp.linalg.solve(M, rhs[..., None]).squeeze(-1)
        # out[...,0] = position, out[...,1] = angle
        return out[..., 0], out[..., 1]

    y_gmte, theta_y_gmte = solve_component(YA_y, YB_y)
    x_gmte, theta_x_gmte = solve_component(YA_x, YB_x)

    return x_gmte, y_gmte, z, theta_x_gmte, theta_y_gmte








